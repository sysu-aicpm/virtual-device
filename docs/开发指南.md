# 开发指南

## 项目结构

```
virtual-device/
├── app.py              # 主应用入口
├── config.py           # 配置文件
├── requirements.txt    # 项目依赖
├── device/            # 设备模块
│   ├── __init__.py    # 模块初始化
│   ├── base_device.py # 基础设备类
│   └── devices.py     # 具体设备实现
└── docs/              # 文档
    ├── API.md         # API文档
    ├── 设备说明.md     # 设备功能说明
    └── 开发指南.md     # 本文档
```

## 添加新设备类型

### 1. 继承基础设备类

所有新设备都应继承 `BaseDevice` 类：

```python
from .base_device import BaseDevice

class NewDevice(BaseDevice):
    def __init__(self, device_id, ip_addr, ip_port):
        super().__init__(device_id, "new_device_type", ip_addr, ip_port)
        # 初始化设备特有属性
        self.some_property = initial_value
        self.power = default_power  # 设置默认功耗
        # 设备自身状态（不是设备连接状态）
        self.device_state = "standby"  # 设备自身状态
```

### 2. 实现控制方法

必须实现 `control` 方法来处理设备特有的控制命令：

```python
def control(self, action, params):
    if action == "some_action":
        value = params.get("param_name")
        if value is not None and self._validate_value(value):
            self.some_property = value
            # 添加事件到心跳数据中
            self.add_event("property_change", {"property": value})
            return True
    return False
```

### 3. 自定义动态功耗（可选）

可以重写 `_get_dynamic_power_consumption` 方法来提供特定的功耗计算逻辑：

```python
def _get_dynamic_power_consumption(self):
    """自定义功耗计算"""
    base_power = self.power
    # 根据设备状态调整波动范围
    if self.device_state == "active":
        fluctuation = base_power * random.uniform(-0.15, 0.2)
    else:
        fluctuation = base_power * random.uniform(-0.05, 0.05)
    return round(base_power + fluctuation, 2)
```

### 4. 注册设备类型

在 `app.py` 中的 `DEVICE_MAPPING` 字典中注册新设备：

```python
DEVICE_MAPPING = {
    'existing_device': ExistingDevice,
    'new_device': NewDevice  # 添加新设备
}
```

## 最佳实践

### 1. 状态管理
- 设备连接状态（`status`）只能是 `online`/`offline`/`error` 三种之一
- 设备自身功能状态应使用单独的属性（如 `power_state`, `camera_state` 等）
- 所有状态变化都应该通过 `control` 方法进行
- 重要状态变化应该通过 `add_event` 方法添加事件
- 使用有意义的状态名称（如 "on"/"off"，"locked"/"unlocked" 等）

### 2. 错误处理
- 在 `control` 方法中验证所有输入参数
- 使用合理的参数范围限制
- 返回 `False` 表示控制失败，而不是抛出异常

### 3. 事件处理
- 事件类型应该清晰表明发生了什么
- 事件数据应该包含足够的信息以理解状态变化
- 使用 `add_event` 方法添加事件，它们将在下一次心跳中发送
- 事件数据应该是简单的键值对

### 4. 功耗管理
- 设置合理的默认功耗
- 如果设备功耗会随状态变化，确保及时更新
- 功耗单位统一使用瓦特（W）
- 考虑实现自定义的动态功耗计算

### 5. 文档
- 在设备类中添加详细的文档字符串
- 说明所有可用的控制命令和参数
- 描述设备的特有行为和限制

## 示例：新设备实现

这是一个智能窗帘的实现示例：

```python
from .base_device import BaseDevice
import random

class Curtain(BaseDevice):
    def __init__(self, device_id, ip_addr, ip_port):
        super().__init__(device_id, "curtain", ip_addr, ip_port)
        self.position = 0  # 0: 完全关闭, 100: 完全打开
        self.power = 8  # 默认功耗8W
        self.curtain_state = "closed"

    def control(self, action, params):
        if action == "set_position":
            position = params.get("position")
            if position is not None and 0 <= position <= 100:
                self.position = position
                self.curtain_state = "open" if position > 0 else "closed"
                # 添加事件
                self.add_event("position_change", {"position": position})
                return True
        elif action == "switch":
            state = params.get("state")
            if state in ["open", "close"]:
                self.position = 100 if state == "open" else 0
                self.curtain_state = "open" if state == "open" else "closed"
                # 添加事件
                self.add_event("curtain_state_change", {"curtain_state": self.curtain_state})
                return True
        return False
        
    def _get_dynamic_power_consumption(self):
        """自定义功耗计算"""
        # 移动时功耗更高
        base_power = self.power
        if hasattr(self, '_last_position') and self._last_position != self.position:
            # 窗帘正在移动
            base_power = 15
            fluctuation = base_power * random.uniform(-0.05, 0.2)
            # 记录当前位置用于下次比较
            self._last_position = self.position
        else:
            # 静止状态
            fluctuation = base_power * random.uniform(-0.1, 0.1)
            self._last_position = self.position
            
        return round(base_power + fluctuation, 2)
```

## 测试新设备

1. 基本功能测试：
```bash
# 设置设备类型
export DEVICE_TYPE=new_device_type

# 启动设备
python app.py
```

2. API测试：
```bash
# 查询设备状态
curl -X POST http://localhost:5000/query \
     -H "Content-Type: application/json" \
     -d '{"keys": ["status", "some_property"]}'

# 控制设备
curl -X POST http://localhost:5000/control \
     -H "Content-Type: application/json" \
     -d '{"action": "some_action", "params": {"param_name": "value"}}'
``` 